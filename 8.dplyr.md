## dplyr包
### 函数类型：
dplyr基础函数只有5个，名称功能如下：
- `mutate()`:新增变量
- `select()`:选择变量
- `filter()`:筛选观测
- `arrange()`:数据排序
- `summarise()`:描述统计
这5个函数加上用于分组的函数`group_by()`以及管道操作符`%>%`,构成了dplyr的最常用函数。

除此之外，该包还提供了用与合并数据框、随机选取观测、计算变量频次与去之序位等功能的若干函数。

**以下操作请保证已经加载了dplyr包**
#### 1.新增变量：`mutate()`
研究者通常需要基于已有的变量创建新变量，并保存到原数据框中，然后进行后续分析。
基本用法：
```r
mutate(dataframe,
       newvar1 = expression1,
       newvar2 = expression2,
       ...
       )
```
其中，
- `dataframe` 表示待操纵的数据框
- `newvar1` 表示想生成的第1个变量
- `expression1` 表示生成第1个变量的命令。
- 生成更多变量可以以此类推
R中自带数据`women`给出了美国30~39周岁之间女性在不同平均身高下对应的平均体重，
但其单位分别为英寸（in）和磅（lb）。
将其转换为国际单位制会更容易为其他国家的分析者理解，转换公式如下：
- 1bin = 2.54 cm
- 1lb = 0.45 kg
首先观察原始数据。
```
women
```
现在，生成新变量`height_cm`和`weight_kg`，即以cm和kg为单位的身高和体重。命令如下：
```r
mutate(women, 
       height_cm = height * 2.54,
       weight_kg = weight * 0.45
       )
```
BMI指数（身体质量指数)是用体重（单位：kg）除以身高（单位：m）的平方得出的数字，则下面生成各平均身高和平均体重下对应的 BMI 指数，变量命名为bmi，并保留至小数点后1位。
```r
mutate((women,
       height_cm = height * 2.54
       weight_kg = weight * 0.45
       bmi = round((weight_kg / (height_cm / 100) ^ 2）, 1)
       )
```
BMI          | 肥胖程度
-------------|---------
< 18.5       | 偏瘦
 18.5~24.9   | 正常
 25.0~29.9   | 偏胖
 `>=`30.0    | 肥胖

 
 依据该表，对上述的BMI值进行分类，该变量命名为`bmi_class`。
 此时可利用dplyr包中的`case_when()`函数，此函数用于生成多重`if else`条件下的赋值，
 即，将某一变量按照特定取值条件划分为不同类型（因子），具体用法如下：
 ```
 women_bmi01 <- mutate(
   women_bmi,
   bmi_class = case_when(
     bmi < 18.5 ~ "underweight",
     between(bmi, 18.5, 22.9) ~ "normal",
     between(bmi, 23.0, 29.9) ~ "overweight",
     bmi >= 30 ~ "obesity"
     )
    )
  ```
  注意这里利用了dplyr包中的`between()`函数，`between(x, a, b)`的含义就在于
  判定向量`x`中的元素取值是否在闭区间[a,b]内，a,b表示两个实数。
  
  此外，R中的自有函数`cut()`，仍可在`mutate()`框架下完成同样的工作。
  ```r
  women_bmi03 <- mutate(
    women_bmi,
    bmi_class = cut(bmi,
    breaks = c(0, 18.5, 25, 30, 100),
    lables = c("underweight", "normal", "overweight", "obesity"),
   right = F）
    ）
  head(women_bmi03)
  ```
  
 两种方式效果完全相同，使用`cut()`的便利之处在于可以将这一命令潜逃阈整体代码中，使代码变得更为紧凑可读。
 
 `cut()`函数可以将某一连续型变量转换为因子（即转化为分类变量），其用法如下：
 ```
 cut(
   var,
   breaks = ,
   lables = ,
   include.lowest = F，
   right = T
   ...
   )
 ```
 其中，
 - `var`表示待分类的变量
 - `breaks`用于设定分界点
 - `lables`用于设定分组标签
 - `include.lowest`用于设定最小值是否包含在分组中，默认为否
 - `right`用于设定分组的右侧端点值是否包含在本组之内。
 特别要注意的是`break= `的设定与`right= `的设定匹配。例如，若要分4组，则需要有5个分界点。若设定：
 ```
 breaks = c(1, 4, 20, 60, 100)
 ```
 且选择默认设定`right = T`则分组如下：
 - 第1组：(1,4], 1不在分组之内，因为默认`include.lowest = F`
 - 第2组：(4,20]
 - 第3组：(20,60]
 - 第4组：(60,100]
 若选择设定`right = F`,则分组如下：
 - 第1组：(1，4)
 - 第2组：[4,20)
 - 第3组：[20,60)
 - 第4组：[60,100)
 
 [分析者可以按照实际需求设定是否包含右侧端点值。最值的设定可以按实际变量的取值范围而字形设定，通常可以小于带分组变量的实际最小值或大于其实际最大值，以使所有取值都包含在某一分组之中。]

#### 2.选择变量：`select()`
当一个数据框包含太多并不一定在一次分析中使用到的变量、即存在太多无关的列时，选择部分变量（列）另存为某一数据对象，对新对象进行数据操纵是更为方便的。尤其使用于对大型社会经济调查的问卷分析中。研究者通常只需要选取其中的若干个变量进行分析，而无需使用其中的全部变量。此时即可使用`select()`函数。
`select()`函数的用法如下：
```r
select(dataframe, var1, var2, ...)
```
其中，
dataframe 表示待选取变量的数据框
var1, var2 表示原数据框中的变量名
以 R 自带的数据mtcars为例进行说明。
```r
names(mtcars)
mtcars_subset1 <- select(mtcars, wt, mpg)
head(mtcars_subset1, 2)
```
`select()`函数也允许通过减号`-`来剔除变量。
```
mtcars_subset2 <- select(mtcars, -c(wt, mpg))
head(mtcars_subset2, 2)
```
此时返回除`mpg`和`wt`这两列的所有的其他变量。

使用`vra1:var2`的形式能够选择指定两个变量之间的所有变量（包括这两个变量本身）。
```r
names(select(mtcars, am: hp))
names(select(mtcars, -c(am: hp))
```
`select()`还可以用于变量的重命名，其方式为：
```
select(data, new_var_name1 = old_var_name2 = old_var_name2, ...)
```
这种处理对许多社会调查问卷的数据产生极大的便利，因为这些数据在录入时通常只被编码为`a101`、`a102`等脱离实际意义的代码，而通过对它们进行重命名，可使分析过程更具可读性。
`select()`函数自动剔除未选中的变量，欲保留其他未选中的变量而只对选中变量进行重命名，可使用`rename()`函数。
```
mtcars_renamed <- rename(mtcars, x= mpg)
head(mtcars_renamed, 2)
```
`select()`的功能不仅如此。在此函数中通过适当的参数设置，可以更高效的选择变量，相关参数如下：
- `starts_with(" ")`:选取以特定字符串开头的变量
- `ends_with(" ")`: 选取以特定字符串结尾的变量
- `contains(" ")`:选取包含特定字符串的变量
- `matches(" ")`:选取匹配给定正则表达式的变量
- `num_range("x", 1:3)`:选取形如`"x1"`,`x2`,`x3`之类的、指定数字范围的变量
- `one_of("a", "b", "c"):选取括号中的所有变量
- `everything(): 选取所有变量
下面以`cgss2013.dta`数据为例，选择部分参数进行示例，其余参数设置效果可类推得知。
```
library(haven)
cgss2013 <- read_dta("cgss2013.dta")
length(names(cgss2013))
```





